{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Flask Download Button Flask-Download-Btn defines a SQLALchemy Mixin for creating Bootstrap download buttons in a Flask application. Its features include: Automatic enabling and disabling. A download button is automatically disabled on click and re-enabled on download completion. CSRF protection. The download button checks for a CSRF authentication token to ensure the client has permission to download the requested file. Web form handling. Download buttons are responsive to web forms. Pre-download operations. Download buttons can easily perform operations before files are downloaded, making it easy to create temporary download files. Progress bar. Update your clients on download progress with server sent events. Installation $ pip install flask-download-btn Quickstart Our folder structure will look like: templates/ index.html app.py In templates/index.html , paste the following Jinja template: <html> <head> <!-- include Bootstrap CSS and Javascript --> <link rel=\"stylesheet\" href=\"https://stackpath.bootstrapcdn.com/bootstrap/4.4.1/css/bootstrap.min.css\"> <script src=\"https://code.jquery.com/jquery-3.4.1.min.js\"></script> <script src=\"https://cdn.jsdelivr.net/npm/popper.js@1.16.0/dist/umd/popper.min.js\"></script> <script src=\"https://stackpath.bootstrapcdn.com/bootstrap/4.4.1/js/bootstrap.min.js\"></script> <!-- include download button script --> {{ download_btn.script() }} </head> <body> <!-- render the download button and progress bar --> {{ download_btn.btn.render() }} {{ download_btn.render_progress() }} </body> </html> In app.py : from flask_download_btn import DownloadBtnManager, DownloadBtnMixin from flask import Flask, render_template, session from flask_sqlalchemy import SQLAlchemy from sqlalchemy.ext.orderinglist import ordering_list app = Flask(__name__) app.config['SECRET_KEY'] = 'secret' app.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///:memory:' app.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = False db = SQLAlchemy(app) # initialize download button manager with application and database download_btn_manager = DownloadBtnManager(app, db=db) # create download button model and register it with the manager @DownloadBtnManager.register class DownloadBtn(DownloadBtnMixin, db.Model): id = db.Column(db.Integer, primary_key=True) # create the database and clear the session when the app starts @app.before_first_request def before_first_request(): db.create_all() session.clear() HELLO_WORLD_URL = 'https://test-bucket2357.s3.us-east-2.amazonaws.com/hello_world.txt' # basic use @app.route('/') def index(): btn = DownloadBtn() btn.downloads = [(HELLO_WORLD_URL, 'hello_world.txt')] db.session.commit() return render_template('index.html', download_btn=btn) Run the app with: $ python app.py And navigate to http://localhost:5000/ . Click the download button to download a text file with 'Hello, World!' . Citation @software{bowen2020flask-download-btn, author = {Dillon Bowen}, title = {Flask-Download-Btn}, url = {https://dsbowen.github.io/flask-download-btn/}, date = {2020-06-17}, } License Users must cite Docstring-Markdown in any publications which use this software. Docstring-Markdown is licensed with the MIT License .","title":"Home"},{"location":"#flask-download-button","text":"Flask-Download-Btn defines a SQLALchemy Mixin for creating Bootstrap download buttons in a Flask application. Its features include: Automatic enabling and disabling. A download button is automatically disabled on click and re-enabled on download completion. CSRF protection. The download button checks for a CSRF authentication token to ensure the client has permission to download the requested file. Web form handling. Download buttons are responsive to web forms. Pre-download operations. Download buttons can easily perform operations before files are downloaded, making it easy to create temporary download files. Progress bar. Update your clients on download progress with server sent events.","title":"Flask Download Button"},{"location":"#installation","text":"$ pip install flask-download-btn","title":"Installation"},{"location":"#quickstart","text":"Our folder structure will look like: templates/ index.html app.py In templates/index.html , paste the following Jinja template: <html> <head> <!-- include Bootstrap CSS and Javascript --> <link rel=\"stylesheet\" href=\"https://stackpath.bootstrapcdn.com/bootstrap/4.4.1/css/bootstrap.min.css\"> <script src=\"https://code.jquery.com/jquery-3.4.1.min.js\"></script> <script src=\"https://cdn.jsdelivr.net/npm/popper.js@1.16.0/dist/umd/popper.min.js\"></script> <script src=\"https://stackpath.bootstrapcdn.com/bootstrap/4.4.1/js/bootstrap.min.js\"></script> <!-- include download button script --> {{ download_btn.script() }} </head> <body> <!-- render the download button and progress bar --> {{ download_btn.btn.render() }} {{ download_btn.render_progress() }} </body> </html> In app.py : from flask_download_btn import DownloadBtnManager, DownloadBtnMixin from flask import Flask, render_template, session from flask_sqlalchemy import SQLAlchemy from sqlalchemy.ext.orderinglist import ordering_list app = Flask(__name__) app.config['SECRET_KEY'] = 'secret' app.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///:memory:' app.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = False db = SQLAlchemy(app) # initialize download button manager with application and database download_btn_manager = DownloadBtnManager(app, db=db) # create download button model and register it with the manager @DownloadBtnManager.register class DownloadBtn(DownloadBtnMixin, db.Model): id = db.Column(db.Integer, primary_key=True) # create the database and clear the session when the app starts @app.before_first_request def before_first_request(): db.create_all() session.clear() HELLO_WORLD_URL = 'https://test-bucket2357.s3.us-east-2.amazonaws.com/hello_world.txt' # basic use @app.route('/') def index(): btn = DownloadBtn() btn.downloads = [(HELLO_WORLD_URL, 'hello_world.txt')] db.session.commit() return render_template('index.html', download_btn=btn) Run the app with: $ python app.py And navigate to http://localhost:5000/ . Click the download button to download a text file with 'Hello, World!' .","title":"Quickstart"},{"location":"#citation","text":"@software{bowen2020flask-download-btn, author = {Dillon Bowen}, title = {Flask-Download-Btn}, url = {https://dsbowen.github.io/flask-download-btn/}, date = {2020-06-17}, }","title":"Citation"},{"location":"#license","text":"Users must cite Docstring-Markdown in any publications which use this software. Docstring-Markdown is licensed with the MIT License .","title":"License"},{"location":"basic/","text":"Basic use We start with a basic example in which we create a download button with a single download file. The download URL is HELLO_WORLD_URL , and the download file will be named hello_world.txt . Put this view function in app.py @app.route('/') def index(): btn = DownloadBtn() btn.downloads = [(HELLO_WORLD_URL, 'hello_world.txt')] db.session.commit() return render_template('index.html', download_btn=btn) Now we are ready to run our app. In your terminal window, enter: $ python app.py And navigate to http://localhost:5000/ . Click the download button to download hello_world.txt . Downloading multiple files We create a download button which downloads two files: hello_world.txt and hello_moon.txt . @app.route('/multi-file') def multi_file(): btn = DownloadBtn() btn.downloads = [ (HELLO_WORLD_URL, 'hello_world.txt'), (HELLO_MOON_URL, 'hello_moon.txt') ] db.session.commit() return render_template('index.html', download_btn=btn) Callback routes This download button will redirect the client to a 'Success' page after the download has finished. from flask import url_for @app.route('/callback') def callback(): btn = DownloadBtn() btn.downloads = [(HELLO_WORLD_URL, 'hello_world.txt')] btn.callback = url_for('download_success') db.session.commit() return render_template('index.html', download_btn=btn) @app.route('/download-success') def download_success(): return 'Download Successful'","title":"Basic use"},{"location":"basic/#basic-use","text":"We start with a basic example in which we create a download button with a single download file. The download URL is HELLO_WORLD_URL , and the download file will be named hello_world.txt . Put this view function in app.py @app.route('/') def index(): btn = DownloadBtn() btn.downloads = [(HELLO_WORLD_URL, 'hello_world.txt')] db.session.commit() return render_template('index.html', download_btn=btn) Now we are ready to run our app. In your terminal window, enter: $ python app.py And navigate to http://localhost:5000/ . Click the download button to download hello_world.txt .","title":"Basic use"},{"location":"basic/#downloading-multiple-files","text":"We create a download button which downloads two files: hello_world.txt and hello_moon.txt . @app.route('/multi-file') def multi_file(): btn = DownloadBtn() btn.downloads = [ (HELLO_WORLD_URL, 'hello_world.txt'), (HELLO_MOON_URL, 'hello_moon.txt') ] db.session.commit() return render_template('index.html', download_btn=btn)","title":"Downloading multiple files"},{"location":"basic/#callback-routes","text":"This download button will redirect the client to a 'Success' page after the download has finished. from flask import url_for @app.route('/callback') def callback(): btn = DownloadBtn() btn.downloads = [(HELLO_WORLD_URL, 'hello_world.txt')] btn.callback = url_for('download_success') db.session.commit() return render_template('index.html', download_btn=btn) @app.route('/download-success') def download_success(): return 'Download Successful'","title":"Callback routes"},{"location":"contribute/","text":"Contribute I welcome contributions to this project, especially Jinja templates for download buttons and progress bars compatible with stylesheets other than Bootstrap 4.","title":"Contribute"},{"location":"contribute/#contribute","text":"I welcome contributions to this project, especially Jinja templates for download buttons and progress bars compatible with stylesheets other than Bootstrap 4.","title":"Contribute"},{"location":"create/","text":"File creation We often want to perform an operation before a file is downloaded. This operation often involves creating the download file itself. In this example, we create two temporary download files and report download progress to the client using a progress bar. Relationship We add a create_file_functions relationship from DownloadBtn to Function . @DownloadBtnManager.register class DownloadBtn(DownloadBtnMixin, db.Model): ... create_file_functions = db.relationship( 'Function', order_by='Function.index', collection_class=ordering_list('index'), foreign_keys='Function.create_file_id' ) ... class Function(FunctionMixin, db.Model): ... create_file_id = db.Column(db.Integer, db.ForeignKey('download_btn.id')) View function We add the following view function to app.py . import string from random import choices @app.route('/file-creation') def file_creation(): btn = DownloadBtn() btn.cache = 'default' btn.create_file_functions = [ Function(create_file0, msg='Hello, World!'), Function(create_file1, msg=choices(string.ascii_letters, k=400)) ] db.session.commit() return render_template('index.html', download_btn=btn) Create file functions Create file functions always take the download button to which they are related as their first argument. We can pass in additional arguments and keyword arguments by setting the Function's args and kwargs attributes. In our 0th file creation function, we store Hello, World! in a data URL. We cache the result by exiting the function early if the download button has already been clicked. import time from base64 import b64encode def create_file0(btn, msg): if btn.downloaded: return stage = 'Creating File 0' yield btn.reset(stage=stage, pct_complete=0) data = '' for i, char in enumerate(msg): data += char yield btn.report(stage, 100.0*i/len(msg)) time.sleep(.5) data = b64encode(data.encode()) url = 'data:text/plain;base64,' + data.decode() btn.downloads = [(url, 'tmp_file0.txt')] db.session.commit() yield btn.report(stage, 100.0) In our 1st file creation function, we store a random string of ascii letters in a data URL. Because we want to store a different random string each time the download button is clicked, we store the URL in the download button's tmp_downloads attribute. def create_file1(btn, msg): stage = 'Creating File 1' yield btn.reset(stage, 0) data = '' for i, char in enumerate(msg): data += char yield btn.report(stage, 100.0*i/len(msg)) time.sleep(.01) data = b64encode(data.encode()) url = 'data:text/plain;base64,' + data.decode() btn.tmp_downloads = [(url, 'tmp_file1.txt')] yield btn.report(stage, 100)","title":"File creation"},{"location":"create/#file-creation","text":"We often want to perform an operation before a file is downloaded. This operation often involves creating the download file itself. In this example, we create two temporary download files and report download progress to the client using a progress bar.","title":"File creation"},{"location":"create/#relationship","text":"We add a create_file_functions relationship from DownloadBtn to Function . @DownloadBtnManager.register class DownloadBtn(DownloadBtnMixin, db.Model): ... create_file_functions = db.relationship( 'Function', order_by='Function.index', collection_class=ordering_list('index'), foreign_keys='Function.create_file_id' ) ... class Function(FunctionMixin, db.Model): ... create_file_id = db.Column(db.Integer, db.ForeignKey('download_btn.id'))","title":"Relationship"},{"location":"create/#view-function","text":"We add the following view function to app.py . import string from random import choices @app.route('/file-creation') def file_creation(): btn = DownloadBtn() btn.cache = 'default' btn.create_file_functions = [ Function(create_file0, msg='Hello, World!'), Function(create_file1, msg=choices(string.ascii_letters, k=400)) ] db.session.commit() return render_template('index.html', download_btn=btn)","title":"View function"},{"location":"create/#create-file-functions","text":"Create file functions always take the download button to which they are related as their first argument. We can pass in additional arguments and keyword arguments by setting the Function's args and kwargs attributes. In our 0th file creation function, we store Hello, World! in a data URL. We cache the result by exiting the function early if the download button has already been clicked. import time from base64 import b64encode def create_file0(btn, msg): if btn.downloaded: return stage = 'Creating File 0' yield btn.reset(stage=stage, pct_complete=0) data = '' for i, char in enumerate(msg): data += char yield btn.report(stage, 100.0*i/len(msg)) time.sleep(.5) data = b64encode(data.encode()) url = 'data:text/plain;base64,' + data.decode() btn.downloads = [(url, 'tmp_file0.txt')] db.session.commit() yield btn.report(stage, 100.0) In our 1st file creation function, we store a random string of ascii letters in a data URL. Because we want to store a different random string each time the download button is clicked, we store the URL in the download button's tmp_downloads attribute. def create_file1(btn, msg): stage = 'Creating File 1' yield btn.reset(stage, 0) data = '' for i, char in enumerate(msg): data += char yield btn.report(stage, 100.0*i/len(msg)) time.sleep(.01) data = b64encode(data.encode()) url = 'data:text/plain;base64,' + data.decode() btn.tmp_downloads = [(url, 'tmp_file1.txt')] yield btn.report(stage, 100)","title":"Create file functions"},{"location":"download_btn_mixin/","text":"a.src-href { float: right; } p.attr { margin-top: 0.5em; margin-left: 1em; } p.func-header { background-color: gainsboro; border-radius: 0.1em; padding: 0.5em; padding-left: 1em; } table.field-table { border-radius: 0.1em } Download button mixin flask_download_btn. DownloadBtnMixin class flask_download_btn. DownloadBtnMixin ( btn_template=None, progress_template=None, **kwargs ) [source] Subclass the DownloadnBtnMixin to create download button models. Download buttons are responsible for: Rendering a download button, progress bar, and download script. Web form handling (optional). File creation (optional). Parameters: btn_template : str or None, default=None Name of the download button html template. If None , the download button manager's btn_template is used. progress_template : str or None, default=None Name of the progress bar html template. If None , the download button manager's progress_template is used. **kwargs : You can set the download button's attribtues by passing them as keyword arguments. Attributes: btn : sqlalchemy_mutablesoup.MutableSoup Download button html soup. btn_tag : bs4.Tag Download button tag. btn_text : str, default='Download' Text of the download button. cache : str, default='no-store' Cache response directive. See https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control . callback : str or None, default=None Name of the callback view function. If this is not None , the client is redirected to the callback URL after download has completed. downloads : list, default=[] List of downloads. Items of this list may be URLs (str) or (URL, file_name) tuples (str, str). download_msg : str, default='' Message which will be briefly displayed after the download has completed. downloaded : bool, default=False Indicates that the file(s) associated with this button has been downloaded. form_id : str or None, default=None ID of the form processed by the download button. If you are not processing a form, or there is only one form on the page, leave this as None . If there are multiple forms on the page, set form_id to the ID of the form associated with the download button. progress : sqlalchemy_mutbalesoup.MutableSoup Progress bar html soup. progress_bar : bs4.Tag Progress bar tag. progress_text : bs4.Tag Progress bar text tag. Function attributes: handle_form_functions : list, default=[] HandleForm functions are executed sequentially after the download button is clicked. These functions process the response from any form which may be associated with the download button. create_file_functions : list, default=[] CreateFile functions are executed sequentially after the HandleForm functions. Methods get_id ( self, sfx ) [source] Get the CSS id associated with download button attributes. Parameters: sfx : str Suffix of the CSS id. Suffix values: btn : download button tag csrf : key for CSRF token lookup in session progress : progress bar <div> container progress-bar : progress bar tag progress-txt : progress bar text Returns: id : str Of the form 'self.model_id-sfx'. render_progress ( self ) [source] Render the progress bar inside a container which sets the progress bar display style to none. The contents of the container may be updated with progress reports during file creation. Returns: progress : flask.Markup Rendered progress bar wrapped in a display none container. Insert this into a <body> tag in a Jinja template. script ( self ) [source] Render the download button script. The script will call routes for form handling, file creation, and download. Authentication for these routes requires a CSRF token. This method creates a unique token and stores it in the session. Returns: script : flask.Markup Rendered download button javascript. Insert this into a <head> tag in a Jinja template. clear_csrf ( self ) [source] Clear CSRF token from session. Call this method to revoke client permission to download the file. Returns: CSRF token : str or None reset ( self, stage='', pct_complete=None ) [source] Resets the progress bar by replacing its html. You will typically want to reset the progress bar at the start of a new stage. Parameters: stage : str, default='' Stage of file creation. e.g. 'Compiling file 0'. pct_complete : float or None, default=None Percent of the stage complete. If None , the progress bar will display the stage without a percent complete message. Returns: reset event : str Server sent event to reset the progress bar. report ( self, stage='', pct_complete=None ) [source] Reports file creation progress by updating the progress bar html. Parameters: stage : str, default='' Stage of file creation. e.g. 'Compiling file 0'. pct_complete : float or None, default=None Percent of the stage complete. If None , the progress bar will display the stage without a percent complete message. Returns: report event : str Server sent event to update the progress bar. transition_speed ( self, speed ) [source] Set the transition speed for the progress bar. Parameters: speed : str Number of seconds for the transiton, e.g. '.5s' Returns: transition speed event : str Server sent event to update the transition speed.","title":"Download mixin"},{"location":"download_btn_mixin/#download-button-mixin","text":"","title":"Download button mixin"},{"location":"download_btn_mixin/#flask_download_btndownloadbtnmixin","text":"class flask_download_btn. DownloadBtnMixin ( btn_template=None, progress_template=None, **kwargs ) [source] Subclass the DownloadnBtnMixin to create download button models. Download buttons are responsible for: Rendering a download button, progress bar, and download script. Web form handling (optional). File creation (optional). Parameters: btn_template : str or None, default=None Name of the download button html template. If None , the download button manager's btn_template is used. progress_template : str or None, default=None Name of the progress bar html template. If None , the download button manager's progress_template is used. **kwargs : You can set the download button's attribtues by passing them as keyword arguments. Attributes: btn : sqlalchemy_mutablesoup.MutableSoup Download button html soup. btn_tag : bs4.Tag Download button tag. btn_text : str, default='Download' Text of the download button. cache : str, default='no-store' Cache response directive. See https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control . callback : str or None, default=None Name of the callback view function. If this is not None , the client is redirected to the callback URL after download has completed. downloads : list, default=[] List of downloads. Items of this list may be URLs (str) or (URL, file_name) tuples (str, str). download_msg : str, default='' Message which will be briefly displayed after the download has completed. downloaded : bool, default=False Indicates that the file(s) associated with this button has been downloaded. form_id : str or None, default=None ID of the form processed by the download button. If you are not processing a form, or there is only one form on the page, leave this as None . If there are multiple forms on the page, set form_id to the ID of the form associated with the download button. progress : sqlalchemy_mutbalesoup.MutableSoup Progress bar html soup. progress_bar : bs4.Tag Progress bar tag. progress_text : bs4.Tag Progress bar text tag. Function attributes: handle_form_functions : list, default=[] HandleForm functions are executed sequentially after the download button is clicked. These functions process the response from any form which may be associated with the download button. create_file_functions : list, default=[] CreateFile functions are executed sequentially after the HandleForm functions.","title":"flask_download_btn.DownloadBtnMixin"},{"location":"download_btn_mixin/#methods","text":"get_id ( self, sfx ) [source] Get the CSS id associated with download button attributes. Parameters: sfx : str Suffix of the CSS id. Suffix values: btn : download button tag csrf : key for CSRF token lookup in session progress : progress bar <div> container progress-bar : progress bar tag progress-txt : progress bar text Returns: id : str Of the form 'self.model_id-sfx'. render_progress ( self ) [source] Render the progress bar inside a container which sets the progress bar display style to none. The contents of the container may be updated with progress reports during file creation. Returns: progress : flask.Markup Rendered progress bar wrapped in a display none container. Insert this into a <body> tag in a Jinja template. script ( self ) [source] Render the download button script. The script will call routes for form handling, file creation, and download. Authentication for these routes requires a CSRF token. This method creates a unique token and stores it in the session. Returns: script : flask.Markup Rendered download button javascript. Insert this into a <head> tag in a Jinja template. clear_csrf ( self ) [source] Clear CSRF token from session. Call this method to revoke client permission to download the file. Returns: CSRF token : str or None reset ( self, stage='', pct_complete=None ) [source] Resets the progress bar by replacing its html. You will typically want to reset the progress bar at the start of a new stage. Parameters: stage : str, default='' Stage of file creation. e.g. 'Compiling file 0'. pct_complete : float or None, default=None Percent of the stage complete. If None , the progress bar will display the stage without a percent complete message. Returns: reset event : str Server sent event to reset the progress bar. report ( self, stage='', pct_complete=None ) [source] Reports file creation progress by updating the progress bar html. Parameters: stage : str, default='' Stage of file creation. e.g. 'Compiling file 0'. pct_complete : float or None, default=None Percent of the stage complete. If None , the progress bar will display the stage without a percent complete message. Returns: report event : str Server sent event to update the progress bar. transition_speed ( self, speed ) [source] Set the transition speed for the progress bar. Parameters: speed : str Number of seconds for the transiton, e.g. '.5s' Returns: transition speed event : str Server sent event to update the transition speed.","title":"Methods"},{"location":"form/","text":"Form handling We often want our download button to be responsive to web forms. In this example, we will create a web form which allows clients to select which files they want to download. Template We begin by creating a Jinja template called form-handling.html in the templates folder. Our folder structure looks like: templates/ form-handling.html index.html app.py In form-handling.html : <html> <head> <link rel=\"stylesheet\" href=\"https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css\"> <script src=\"https://code.jquery.com/jquery-3.4.1.min.js\"></script> <script src=\"https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.7/umd/popper.min.js\"></script> <script src=\"https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/js/bootstrap.min.js\"></script> {{ download_btn.script() }} </head> <body> <form> <div id=\"selectFiles\" name=\"selectFiles\"> <p>Select files to download.</p> <div class=\"form-check\"> <input id=\"helloWorld\" name=\"selectFiles\" type=\"checkbox\" class=\"form-check-input\" value=\"hello_world.txt\"> <label class=\"form-check-label\" for=\"helloWorld\">Hello World</label> </div> <div class=\"form-check\"> <input id=\"helloMoon\" name=\"selectFiles\" type=\"checkbox\" class=\"form-check-input\" value=\"hello_moon.txt\"> <label class=\"form-check-label\" for=\"helloMoon\">Hello Moon</label> </div> </div> </form> {{ download_btn.btn.render() }} {{ download_btn.render_progress() }} </body> </html> Function model Forms are handled by Function models . To begin, we define a Function model and give DownloadBtn a relationship to it named handle_form_functions . @DownloadBtnManager.register class DownloadBtn(DownloadBtnMixin, db.Model): ... handle_form_functions = db.relationship( 'Function', order_by='Function.index', collection_class=ordering_list('index'), foreign_keys='Function.handle_form_id' ) from sqlalchemy_function import FunctionMixin class Function(FunctionMixin, db.Model): id = db.Column(db.Integer, primary_key=True) index = db.Column(db.Integer) handle_form_id = db.Column(db.Integer, db.ForeignKey('download_btn.id')) View function Form handling Functions always take the client's form response as their first argument, and the Download Button to which they are related as their second argument. The response is a werkzeug.datastructures.ImmutableMultiDict object. We can pass in additional arguments and keyword arguments by setting the Function's args and kwargs attributes. @app.route('/form-handling') def form_handling(): btn = DownloadBtn() btn.handle_form_functions = select_files db.session.commit() return render_template('form-handling.html', download_btn=btn) def select_files(response, btn): btn.downloads.clear() files = response.getlist('selectFiles') if 'hello_world.txt' in files: btn.downloads.append((HELLO_WORLD_URL, 'hello_world.txt')) if 'hello_moon.txt' in files: btn.downloads.append((HELLO_MOON_URL, 'hello_moon.txt'))","title":"Form handling"},{"location":"form/#form-handling","text":"We often want our download button to be responsive to web forms. In this example, we will create a web form which allows clients to select which files they want to download.","title":"Form handling"},{"location":"form/#template","text":"We begin by creating a Jinja template called form-handling.html in the templates folder. Our folder structure looks like: templates/ form-handling.html index.html app.py In form-handling.html : <html> <head> <link rel=\"stylesheet\" href=\"https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css\"> <script src=\"https://code.jquery.com/jquery-3.4.1.min.js\"></script> <script src=\"https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.7/umd/popper.min.js\"></script> <script src=\"https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/js/bootstrap.min.js\"></script> {{ download_btn.script() }} </head> <body> <form> <div id=\"selectFiles\" name=\"selectFiles\"> <p>Select files to download.</p> <div class=\"form-check\"> <input id=\"helloWorld\" name=\"selectFiles\" type=\"checkbox\" class=\"form-check-input\" value=\"hello_world.txt\"> <label class=\"form-check-label\" for=\"helloWorld\">Hello World</label> </div> <div class=\"form-check\"> <input id=\"helloMoon\" name=\"selectFiles\" type=\"checkbox\" class=\"form-check-input\" value=\"hello_moon.txt\"> <label class=\"form-check-label\" for=\"helloMoon\">Hello Moon</label> </div> </div> </form> {{ download_btn.btn.render() }} {{ download_btn.render_progress() }} </body> </html>","title":"Template"},{"location":"form/#function-model","text":"Forms are handled by Function models . To begin, we define a Function model and give DownloadBtn a relationship to it named handle_form_functions . @DownloadBtnManager.register class DownloadBtn(DownloadBtnMixin, db.Model): ... handle_form_functions = db.relationship( 'Function', order_by='Function.index', collection_class=ordering_list('index'), foreign_keys='Function.handle_form_id' ) from sqlalchemy_function import FunctionMixin class Function(FunctionMixin, db.Model): id = db.Column(db.Integer, primary_key=True) index = db.Column(db.Integer) handle_form_id = db.Column(db.Integer, db.ForeignKey('download_btn.id'))","title":"Function model"},{"location":"form/#view-function","text":"Form handling Functions always take the client's form response as their first argument, and the Download Button to which they are related as their second argument. The response is a werkzeug.datastructures.ImmutableMultiDict object. We can pass in additional arguments and keyword arguments by setting the Function's args and kwargs attributes. @app.route('/form-handling') def form_handling(): btn = DownloadBtn() btn.handle_form_functions = select_files db.session.commit() return render_template('form-handling.html', download_btn=btn) def select_files(response, btn): btn.downloads.clear() files = response.getlist('selectFiles') if 'hello_world.txt' in files: btn.downloads.append((HELLO_WORLD_URL, 'hello_world.txt')) if 'hello_moon.txt' in files: btn.downloads.append((HELLO_MOON_URL, 'hello_moon.txt'))","title":"View function"},{"location":"manager/","text":"a.src-href { float: right; } p.attr { margin-top: 0.5em; margin-left: 1em; } p.func-header { background-color: gainsboro; border-radius: 0.1em; padding: 0.5em; padding-left: 1em; } table.field-table { border-radius: 0.1em } Download button manager flask_download_btn. DownloadBtnManager class flask_download_btn. DownloadBtnManager ( app=None, **kwargs ) [source] The manager has two responsibilities: Register download button classes. Register routes used by the download button. Parameters: app : flask.app.Flask or None, default=None Flask application with which download buttons are associated. **kwargs : You can set the download button manager's attributes by passing them as keyword arguments. Attributes: db : flask_sqlalchemy.SQLAlchemy or None, default=None SQLAlchemy database associated with the Flask app. btn_template : str, default='download_btn/button.html' Path to the default button template. progress_template : str, default='download_btn/progress.html' Path to the default progress bar template. Notes If app and db are not set on initialization, they must be set using the init_app method before the app is run. Examples from flask import Flask from flask_download_btn import DownloadBtnManager from flask_sqlalchemy import SQLAlchemy app = Flask(__name__) app.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///:memory:' app.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = False db = SQLAlchemy(app) download_btn_manager = DownloadBtnManager(app, db) Methods register ( cls, btn_cls ) [source] Decorator for updating the download button class registry. Parameters: btn_cls : class Class of the registered button. Returns: btn_cls : Examples from flask_download_btn import DownloadBtnMixin @DownloadBtnManager.register class DownloadBtn(DownloadBtnMixin, db.Model): ... init_app ( self, app, **kwargs ) [source] Initialize the download button manager with the application. Parameters: app : flask.app.Flask Application with which the download button manager is associated. **kwargs : You can set the download button manager's attributes by passing them as keyword arguments.","title":"Manager"},{"location":"manager/#download-button-manager","text":"","title":"Download button manager"},{"location":"manager/#flask_download_btndownloadbtnmanager","text":"class flask_download_btn. DownloadBtnManager ( app=None, **kwargs ) [source] The manager has two responsibilities: Register download button classes. Register routes used by the download button. Parameters: app : flask.app.Flask or None, default=None Flask application with which download buttons are associated. **kwargs : You can set the download button manager's attributes by passing them as keyword arguments. Attributes: db : flask_sqlalchemy.SQLAlchemy or None, default=None SQLAlchemy database associated with the Flask app. btn_template : str, default='download_btn/button.html' Path to the default button template. progress_template : str, default='download_btn/progress.html' Path to the default progress bar template.","title":"flask_download_btn.DownloadBtnManager"},{"location":"manager/#notes","text":"If app and db are not set on initialization, they must be set using the init_app method before the app is run.","title":"Notes"},{"location":"manager/#examples","text":"from flask import Flask from flask_download_btn import DownloadBtnManager from flask_sqlalchemy import SQLAlchemy app = Flask(__name__) app.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///:memory:' app.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = False db = SQLAlchemy(app) download_btn_manager = DownloadBtnManager(app, db)","title":"Examples"},{"location":"manager/#methods","text":"register ( cls, btn_cls ) [source] Decorator for updating the download button class registry. Parameters: btn_cls : class Class of the registered button. Returns: btn_cls :","title":"Methods"},{"location":"manager/#examples_1","text":"from flask_download_btn import DownloadBtnMixin @DownloadBtnManager.register class DownloadBtn(DownloadBtnMixin, db.Model): ... init_app ( self, app, **kwargs ) [source] Initialize the download button manager with the application. Parameters: app : flask.app.Flask Application with which the download button manager is associated. **kwargs : You can set the download button manager's attributes by passing them as keyword arguments.","title":"Examples"},{"location":"setup/","text":"Setup We begin by setting up a Flask app with a Flask-SQLAlchemy database. To use Flask-Download-Btn, we create a DownloadBtnManager and a DownloadBtn model. Write the following code in app.py . from flask_download_btn import DownloadBtnManager, DownloadBtnMixin from flask import Flask, render_template, session from flask_sqlalchemy import SQLAlchemy from sqlalchemy.ext.orderinglist import ordering_list app = Flask(__name__) app.config['SECRET_KEY'] = 'secret' app.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///:memory:' app.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = False db = SQLAlchemy(app) # initialize download button manager with application and database download_btn_manager = DownloadBtnManager(app, db=db) # create download button model and register it with the manager @DownloadBtnManager.register class DownloadBtn(DownloadBtnMixin, db.Model): id = db.Column(db.Integer, primary_key=True) # LATER: HANDLE FORM AND CREATE FILE FUNCTION RELATIONSHIPS GO HERE # LATER: FUNCTION MODEL DEFINED HERE # create the database and clear the session when the app starts @app.before_first_request def before_first_request(): db.create_all() session.clear() # DOWNLOAD URLS GO HERE # VIEW FUNCTIONS GO HERE if __name__ == '__main__': app.run(debug=True) Next, pick two download URLs, or use mine. HELLO_WORLD_URL = 'https://test-bucket2357.s3.us-east-2.amazonaws.com/hello_world.txt' HELLO_MOON_URL = 'https://test-bucket2357.s3.us-east-2.amazonaws.com/hello_moon.txt' Now create a Jinja template in your templates folder. The template must: Include Bootstrap CSS and Javascript Include the download button script Render the download button and progress bar <html> <head> <!-- include Bootstrap CSS and Javascript --> <link rel=\"stylesheet\" href=\"https://stackpath.bootstrapcdn.com/bootstrap/4.4.1/css/bootstrap.min.css\"> <script src=\"https://code.jquery.com/jquery-3.4.1.min.js\"></script> <script src=\"https://cdn.jsdelivr.net/npm/popper.js@1.16.0/dist/umd/popper.min.js\"></script> <script src=\"https://stackpath.bootstrapcdn.com/bootstrap/4.4.1/js/bootstrap.min.js\"></script> <!-- include download button script --> {{ download_btn.script() }} </head> <body> <!-- render the download button and progress bar --> {{ download_btn.btn.render() }} {{ download_btn.render_progress() }} </body> </html> Our folder structure looks like: templates/ index.html app.py","title":"Setup"},{"location":"setup/#setup","text":"We begin by setting up a Flask app with a Flask-SQLAlchemy database. To use Flask-Download-Btn, we create a DownloadBtnManager and a DownloadBtn model. Write the following code in app.py . from flask_download_btn import DownloadBtnManager, DownloadBtnMixin from flask import Flask, render_template, session from flask_sqlalchemy import SQLAlchemy from sqlalchemy.ext.orderinglist import ordering_list app = Flask(__name__) app.config['SECRET_KEY'] = 'secret' app.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///:memory:' app.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = False db = SQLAlchemy(app) # initialize download button manager with application and database download_btn_manager = DownloadBtnManager(app, db=db) # create download button model and register it with the manager @DownloadBtnManager.register class DownloadBtn(DownloadBtnMixin, db.Model): id = db.Column(db.Integer, primary_key=True) # LATER: HANDLE FORM AND CREATE FILE FUNCTION RELATIONSHIPS GO HERE # LATER: FUNCTION MODEL DEFINED HERE # create the database and clear the session when the app starts @app.before_first_request def before_first_request(): db.create_all() session.clear() # DOWNLOAD URLS GO HERE # VIEW FUNCTIONS GO HERE if __name__ == '__main__': app.run(debug=True) Next, pick two download URLs, or use mine. HELLO_WORLD_URL = 'https://test-bucket2357.s3.us-east-2.amazonaws.com/hello_world.txt' HELLO_MOON_URL = 'https://test-bucket2357.s3.us-east-2.amazonaws.com/hello_moon.txt' Now create a Jinja template in your templates folder. The template must: Include Bootstrap CSS and Javascript Include the download button script Render the download button and progress bar <html> <head> <!-- include Bootstrap CSS and Javascript --> <link rel=\"stylesheet\" href=\"https://stackpath.bootstrapcdn.com/bootstrap/4.4.1/css/bootstrap.min.css\"> <script src=\"https://code.jquery.com/jquery-3.4.1.min.js\"></script> <script src=\"https://cdn.jsdelivr.net/npm/popper.js@1.16.0/dist/umd/popper.min.js\"></script> <script src=\"https://stackpath.bootstrapcdn.com/bootstrap/4.4.1/js/bootstrap.min.js\"></script> <!-- include download button script --> {{ download_btn.script() }} </head> <body> <!-- render the download button and progress bar --> {{ download_btn.btn.render() }} {{ download_btn.render_progress() }} </body> </html> Our folder structure looks like: templates/ index.html app.py","title":"Setup"},{"location":"style/","text":"Putting it all together In this final example, we use both handle form and create file functions and add some style to our download button and progress bar. Create a style.html Jinja template. Our folder structure looks like: templates/ form-handling.html index.html style.html app.py The template looks like: <html> <head> <link rel=\"stylesheet\" href=\"https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css\"> <script src=\"https://code.jquery.com/jquery-3.4.1.min.js\"></script> <script src=\"https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.7/umd/popper.min.js\"></script> <script src=\"https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/js/bootstrap.min.js\"></script> {{ download_btn.script() }} </head> <body> <div class=\"container h-100\"> <div class=\"row h-100 justify-content-center align-items-center\"> <form> {{ download_btn.render_progress() }} <div id=\"selectFiles\" name=\"selectFiles\"> <p>Select files to download.</p> <div class=\"custom-control custom-checkbox\"> <input id=\"helloWorld\" name=\"selectFiles\" type=\"checkbox\" class=\"custom-control-input\" value=\"hello_world.txt\"> <label class=\"custom-control-label\" for=\"helloWorld\">Hello World</label> </div> <div class=\"custom-control custom-checkbox\"> <input id=\"ascii\" name=\"selectFiles\" type=\"checkbox\" class=\"custom-control-input\" value=\"ascii.txt\"> <label class=\"custom-control-label\" for=\"ascii\">Random ascii</label> </div> </div> <br> {{ download_btn.btn.render() }} </form> </div> </div> </body> </html> In app.py : @app.route('/style') def style(): btn = DownloadBtn() btn.btn_text = 'Custom Button Text' btn.btn_tag['class'].remove('btn-primary') btn.btn_tag['class'].append('btn-outline-primary') btn.progress_bar['class'] += [ 'progress-bar-striped', 'progress-bar-animated' ] btn.handle_form_functions = select_tmp_files btn.download_msg = 'Download Complete' db.session.commit() return render_template('style.html', download_btn=btn) def select_tmp_files(response, btn): btn.downloads.clear() btn.create_file_functions.clear() files = response.getlist('selectFiles') if 'hello_world.txt' in files: btn.downloads = [(HELLO_WORLD_URL, 'hello_world.txt')] if 'ascii.txt' in files: btn.create_file_functions = [ Function(create_file1, choices(string.ascii_letters, k=200)) ]","title":"Style"},{"location":"style/#putting-it-all-together","text":"In this final example, we use both handle form and create file functions and add some style to our download button and progress bar. Create a style.html Jinja template. Our folder structure looks like: templates/ form-handling.html index.html style.html app.py The template looks like: <html> <head> <link rel=\"stylesheet\" href=\"https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css\"> <script src=\"https://code.jquery.com/jquery-3.4.1.min.js\"></script> <script src=\"https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.7/umd/popper.min.js\"></script> <script src=\"https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/js/bootstrap.min.js\"></script> {{ download_btn.script() }} </head> <body> <div class=\"container h-100\"> <div class=\"row h-100 justify-content-center align-items-center\"> <form> {{ download_btn.render_progress() }} <div id=\"selectFiles\" name=\"selectFiles\"> <p>Select files to download.</p> <div class=\"custom-control custom-checkbox\"> <input id=\"helloWorld\" name=\"selectFiles\" type=\"checkbox\" class=\"custom-control-input\" value=\"hello_world.txt\"> <label class=\"custom-control-label\" for=\"helloWorld\">Hello World</label> </div> <div class=\"custom-control custom-checkbox\"> <input id=\"ascii\" name=\"selectFiles\" type=\"checkbox\" class=\"custom-control-input\" value=\"ascii.txt\"> <label class=\"custom-control-label\" for=\"ascii\">Random ascii</label> </div> </div> <br> {{ download_btn.btn.render() }} </form> </div> </div> </body> </html> In app.py : @app.route('/style') def style(): btn = DownloadBtn() btn.btn_text = 'Custom Button Text' btn.btn_tag['class'].remove('btn-primary') btn.btn_tag['class'].append('btn-outline-primary') btn.progress_bar['class'] += [ 'progress-bar-striped', 'progress-bar-animated' ] btn.handle_form_functions = select_tmp_files btn.download_msg = 'Download Complete' db.session.commit() return render_template('style.html', download_btn=btn) def select_tmp_files(response, btn): btn.downloads.clear() btn.create_file_functions.clear() files = response.getlist('selectFiles') if 'hello_world.txt' in files: btn.downloads = [(HELLO_WORLD_URL, 'hello_world.txt')] if 'ascii.txt' in files: btn.create_file_functions = [ Function(create_file1, choices(string.ascii_letters, k=200)) ]","title":"Putting it all together"}]}